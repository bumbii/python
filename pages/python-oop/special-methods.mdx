# Special Methods (Magic Methods)

## Special Methods l√† g√¨?

**Special Methods** (c√≤n g·ªçi l√† **Magic Methods** ho·∫∑c **Dunder Methods**) l√† c√°c ph∆∞∆°ng th·ª©c ƒë·∫∑c bi·ªát trong Python v·ªõi t√™n b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c b·∫±ng `__` (double underscore).

V√≠ d·ª•: `__init__`, `__str__`, `__add__`, `__len__`

## T·∫°i sao g·ªçi l√† "Magic"?

C√°c ph∆∞∆°ng th·ª©c n√†y ƒë∆∞·ª£c Python g·ªçi t·ª± ƒë·ªông trong m·ªôt s·ªë t√¨nh hu·ªëng ƒë·∫∑c bi·ªát:
- `__init__()` ƒë∆∞·ª£c g·ªçi khi t·∫°o object
- `__str__()` ƒë∆∞·ª£c g·ªçi khi d√πng `print()`
- `__add__()` ƒë∆∞·ª£c g·ªçi khi d√πng to√°n t·ª≠ `+`
- `__len__()` ƒë∆∞·ª£c g·ªçi khi d√πng h√†m `len()`

## C√°c Special Methods ph·ªï bi·∫øn

### 1. Object Initialization v√† Representation

#### `__init__(self, ...)` - Constructor
Kh·ªüi t·∫°o object khi t·∫°o m·ªõi.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

person = Person("An", 20)  # __init__ ƒë∆∞·ª£c g·ªçi t·ª± ƒë·ªông
```

#### `__str__(self)` - String Representation (cho ng∆∞·ªùi d√πng)
Tr·∫£ v·ªÅ chu·ªói khi d√πng `print()` ho·∫∑c `str()`.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"{self.name}, {self.age} tu·ªïi"

person = Person("An", 20)
print(person)  # An, 20 tu·ªïi
```

#### `__repr__(self)` - Official Representation (cho l·∫≠p tr√¨nh vi√™n)
Tr·∫£ v·ªÅ chu·ªói ƒë·∫°i di·ªán ch√≠nh th·ª©c c·ªßa object.

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f"Person(name='{self.name}', age={self.age})"

    def __str__(self):
        return f"{self.name}, {self.age} tu·ªïi"

person = Person("An", 20)
print(person)      # An, 20 tu·ªïi (__str__)
print(repr(person))  # Person(name='An', age=20) (__repr__)
```

### 2. Comparison Operators (To√°n t·ª≠ so s√°nh)

```python
class Student:
    def __init__(self, name, gpa):
        self.name = name
        self.gpa = gpa

    def __eq__(self, other):
        """Equal: =="""
        return self.gpa == other.gpa

    def __ne__(self, other):
        """Not equal: !="""
        return self.gpa != other.gpa

    def __lt__(self, other):
        """Less than: <"""
        return self.gpa < other.gpa

    def __le__(self, other):
        """Less than or equal: <="""
        return self.gpa <= other.gpa

    def __gt__(self, other):
        """Greater than: >"""
        return self.gpa > other.gpa

    def __ge__(self, other):
        """Greater than or equal: >="""
        return self.gpa >= other.gpa

    def __str__(self):
        return f"{self.name} (GPA: {self.gpa})"

s1 = Student("An", 3.5)
s2 = Student("B√¨nh", 3.2)
s3 = Student("C∆∞·ªùng", 3.5)

print(s1 == s3)  # True (__eq__)
print(s1 != s2)  # True (__ne__)
print(s1 > s2)   # True (__gt__)
print(s1 <= s3)  # True (__le__)
```

### 3. Arithmetic Operators (To√°n t·ª≠ s·ªë h·ªçc)

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, other):
        """Addition: +"""
        return Vector(self.x + other.x, self.y + other.y)

    def __sub__(self, other):
        """Subtraction: -"""
        return Vector(self.x - other.x, self.y - other.y)

    def __mul__(self, scalar):
        """Multiplication: *"""
        if isinstance(scalar, (int, float)):
            return Vector(self.x * scalar, self.y * scalar)
        raise TypeError("Ph·∫£i nh√¢n v·ªõi s·ªë")

    def __truediv__(self, scalar):
        """Division: /"""
        if isinstance(scalar, (int, float)):
            return Vector(self.x / scalar, self.y / scalar)
        raise TypeError("Ph·∫£i chia cho s·ªë")

    def __str__(self):
        return f"Vector({self.x}, {self.y})"

v1 = Vector(4, 2)
v2 = Vector(2, 1)

print(v1 + v2)  # Vector(6, 3)
print(v1 - v2)  # Vector(2, 1)
print(v1 * 3)   # Vector(12, 6)
print(v1 / 2)   # Vector(2.0, 1.0)
```

### 4. Container Methods

#### `__len__(self)` - Length
```python
class Playlist:
    def __init__(self, name):
        self.name = name
        self.songs = []

    def add_song(self, song):
        self.songs.append(song)

    def __len__(self):
        return len(self.songs)

playlist = Playlist("My Favorites")
playlist.add_song("Song 1")
playlist.add_song("Song 2")
playlist.add_song("Song 3")

print(len(playlist))  # 3
```

#### `__getitem__(self, key)` v√† `__setitem__(self, key, value)` - Indexing
```python
class ShoppingCart:
    def __init__(self):
        self.items = []

    def add_item(self, item):
        self.items.append(item)

    def __getitem__(self, index):
        """Cho ph√©p cart[index]"""
        return self.items[index]

    def __setitem__(self, index, value):
        """Cho ph√©p cart[index] = value"""
        self.items[index] = value

    def __len__(self):
        return len(self.items)

cart = ShoppingCart()
cart.add_item("Laptop")
cart.add_item("Mouse")
cart.add_item("Keyboard")

print(cart[0])   # Laptop (__getitem__)
print(cart[1])   # Mouse

cart[1] = "Gaming Mouse"  # __setitem__
print(cart[1])   # Gaming Mouse

# C√≥ th·ªÉ d√πng trong v√≤ng l·∫∑p
for item in cart:
    print(item)
```

#### `__contains__(self, item)` - Membership Test
```python
class Team:
    def __init__(self, name):
        self.name = name
        self.members = []

    def add_member(self, member):
        self.members.append(member)

    def __contains__(self, member):
        """Cho ph√©p d√πng 'in'"""
        return member in self.members

team = Team("Dev Team")
team.add_member("An")
team.add_member("B√¨nh")

print("An" in team)      # True
print("C∆∞·ªùng" in team)   # False
```

### 5. Iteration

#### `__iter__(self)` v√† `__next__(self)` - Iterator Protocol
```python
class Countdown:
    def __init__(self, start):
        self.start = start

    def __iter__(self):
        self.current = self.start
        return self

    def __next__(self):
        if self.current <= 0:
            raise StopIteration
        self.current -= 1
        return self.current + 1

# S·ª≠ d·ª•ng
countdown = Countdown(5)
for num in countdown:
    print(num)  # 5, 4, 3, 2, 1
```

### 6. Context Manager

#### `__enter__(self)` v√† `__exit__(self)` - D√πng v·ªõi `with`
```python
class FileManager:
    def __init__(self, filename, mode):
        self.filename = filename
        self.mode = mode
        self.file = None

    def __enter__(self):
        """ƒê∆∞·ª£c g·ªçi khi v√†o block with"""
        self.file = open(self.filename, self.mode)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        """ƒê∆∞·ª£c g·ªçi khi ra kh·ªèi block with"""
        if self.file:
            self.file.close()

# S·ª≠ d·ª•ng
with FileManager('test.txt', 'w') as f:
    f.write('Hello World')
# File t·ª± ƒë·ªông ƒë√≥ng sau khi ra kh·ªèi block
```

### 7. Callable Objects

#### `__call__(self)` - G·ªçi object nh∆∞ h√†m
```python
class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, value):
        """Cho ph√©p g·ªçi object nh∆∞ h√†m"""
        return value * self.factor

double = Multiplier(2)
triple = Multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

## V√≠ d·ª• th·ª±c t·∫ø: Class Money

```python
class Money:
    def __init__(self, amount, currency="VND"):
        self.amount = amount
        self.currency = currency

    def __str__(self):
        """String representation"""
        return f"{self.amount:,.0f} {self.currency}"

    def __repr__(self):
        """Official representation"""
        return f"Money({self.amount}, '{self.currency}')"

    def __add__(self, other):
        """Addition"""
        if isinstance(other, Money):
            if self.currency != other.currency:
                raise ValueError("Kh√¥ng th·ªÉ c·ªông hai ƒë∆°n v·ªã ti·ªÅn t·ªá kh√°c nhau!")
            return Money(self.amount + other.amount, self.currency)
        elif isinstance(other, (int, float)):
            return Money(self.amount + other, self.currency)
        raise TypeError("Kh√¥ng th·ªÉ c·ªông Money v·ªõi ki·ªÉu n√†y")

    def __sub__(self, other):
        """Subtraction"""
        if isinstance(other, Money):
            if self.currency != other.currency:
                raise ValueError("Kh√¥ng th·ªÉ tr·ª´ hai ƒë∆°n v·ªã ti·ªÅn t·ªá kh√°c nhau!")
            return Money(self.amount - other.amount, self.currency)
        elif isinstance(other, (int, float)):
            return Money(self.amount - other, self.currency)
        raise TypeError("Kh√¥ng th·ªÉ tr·ª´ Money v·ªõi ki·ªÉu n√†y")

    def __mul__(self, scalar):
        """Multiplication"""
        if isinstance(scalar, (int, float)):
            return Money(self.amount * scalar, self.currency)
        raise TypeError("Ch·ªâ c√≥ th·ªÉ nh√¢n Money v·ªõi s·ªë")

    def __truediv__(self, scalar):
        """Division"""
        if isinstance(scalar, (int, float)):
            return Money(self.amount / scalar, self.currency)
        raise TypeError("Ch·ªâ c√≥ th·ªÉ chia Money cho s·ªë")

    def __eq__(self, other):
        """Equal"""
        if isinstance(other, Money):
            return self.amount == other.amount and self.currency == other.currency
        return False

    def __lt__(self, other):
        """Less than"""
        if isinstance(other, Money):
            if self.currency != other.currency:
                raise ValueError("Kh√¥ng th·ªÉ so s√°nh hai ƒë∆°n v·ªã ti·ªÅn t·ªá kh√°c nhau!")
            return self.amount < other.amount
        raise TypeError("Kh√¥ng th·ªÉ so s√°nh Money v·ªõi ki·ªÉu n√†y")

    def __le__(self, other):
        """Less than or equal"""
        return self == other or self < other

    def __bool__(self):
        """Boolean conversion"""
        return self.amount > 0

# S·ª≠ d·ª•ng
m1 = Money(100000)
m2 = Money(50000)

print(m1)           # 100,000 VND
print(repr(m1))     # Money(100000, 'VND')

m3 = m1 + m2
print(m3)           # 150,000 VND

m4 = m1 - m2
print(m4)           # 50,000 VND

m5 = m1 * 2
print(m5)           # 200,000 VND

m6 = m1 / 2
print(m6)           # 50,000 VND

print(m1 > m2)      # True
print(m1 == m2)     # False

if m1:
    print("C√≥ ti·ªÅn!")  # C√≥ ti·ªÅn!
```

## V√≠ d·ª•: Class Range (t·ª± implement)

```python
class MyRange:
    """T·ª± implement class t∆∞∆°ng t·ª± range() c·ªßa Python"""
    def __init__(self, start, stop=None, step=1):
        if stop is None:
            self.start = 0
            self.stop = start
        else:
            self.start = start
            self.stop = stop
        self.step = step

    def __iter__(self):
        self.current = self.start
        return self

    def __next__(self):
        if (self.step > 0 and self.current >= self.stop) or \
           (self.step < 0 and self.current <= self.stop):
            raise StopIteration
        value = self.current
        self.current += self.step
        return value

    def __len__(self):
        return max(0, (self.stop - self.start + self.step - 1) // self.step)

    def __getitem__(self, index):
        if index < 0 or index >= len(self):
            raise IndexError("Index out of range")
        return self.start + index * self.step

    def __contains__(self, value):
        if self.step > 0:
            return self.start <= value < self.stop and \
                   (value - self.start) % self.step == 0
        else:
            return self.stop < value <= self.start and \
                   (value - self.start) % self.step == 0

    def __str__(self):
        return f"MyRange({self.start}, {self.stop}, {self.step})"

# S·ª≠ d·ª•ng
r = MyRange(0, 10, 2)

print(r)           # MyRange(0, 10, 2)
print(len(r))      # 5
print(r[2])        # 4
print(4 in r)      # True
print(5 in r)      # False

for num in r:
    print(num)     # 0, 2, 4, 6, 8
```

## B·∫£ng t·ªïng h·ª£p Special Methods

| Lo·∫°i | Method | M√¥ t·∫£ |
|------|--------|-------|
| **Kh·ªüi t·∫°o** | `__init__(self, ...)` | Constructor |
| | `__new__(cls, ...)` | T·∫°o instance m·ªõi |
| | `__del__(self)` | Destructor |
| **Representation** | `__str__(self)` | `str()`, `print()` |
| | `__repr__(self)` | `repr()`, representation ch√≠nh th·ª©c |
| **So s√°nh** | `__eq__(self, other)` | `==` |
| | `__ne__(self, other)` | `!=` |
| | `__lt__(self, other)` | `<` |
| | `__le__(self, other)` | `<=` |
| | `__gt__(self, other)` | `>` |
| | `__ge__(self, other)` | `>=` |
| **To√°n t·ª≠ s·ªë h·ªçc** | `__add__(self, other)` | `+` |
| | `__sub__(self, other)` | `-` |
| | `__mul__(self, other)` | `*` |
| | `__truediv__(self, other)` | `/` |
| | `__floordiv__(self, other)` | `//` |
| | `__mod__(self, other)` | `%` |
| | `__pow__(self, other)` | `**` |
| **Container** | `__len__(self)` | `len()` |
| | `__getitem__(self, key)` | `obj[key]` |
| | `__setitem__(self, key, value)` | `obj[key] = value` |
| | `__delitem__(self, key)` | `del obj[key]` |
| | `__contains__(self, item)` | `in` |
| **Iteration** | `__iter__(self)` | Iterator |
| | `__next__(self)` | Next item |
| **Callable** | `__call__(self, ...)` | `obj()` |
| **Context Manager** | `__enter__(self)` | `with` statement entry |
| | `__exit__(self, ...)` | `with` statement exit |
| **Attribute Access** | `__getattr__(self, name)` | Get attribute |
| | `__setattr__(self, name, value)` | Set attribute |
| | `__delattr__(self, name)` | Delete attribute |

## T·ªïng k·∫øt

- **Special Methods** cho ph√©p class c·ªßa b·∫°n ho·∫°t ƒë·ªông gi·ªëng built-in types
- B·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c b·∫±ng `__` (dunder - double underscore)
- ƒê∆∞·ª£c Python g·ªçi t·ª± ƒë·ªông trong c√°c t√¨nh hu·ªëng ƒë·∫∑c bi·ªát
- Gi√∫p code tr·ªü n√™n Pythonic v√† tr·ª±c quan h∆°n
- Cho ph√©p overload operators v√† implement protocols

Ch√∫c m·ª´ng b·∫°n ƒë√£ ho√†n th√†nh series v·ªÅ OOP trong Python! üéâ
